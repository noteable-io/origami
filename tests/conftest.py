import logging
import logging.config
import os
import uuid
from typing import Optional

import httpx
import pytest
import structlog

from origami.clients.api import APIClient
from origami.models.api.files import File
from origami.models.api.projects import Project
from origami.models.notebook import Notebook

logger = structlog.get_logger()


@pytest.fixture(autouse=True, scope='session')
def setup_logging():
    structlog.configure(
        processors=[
            structlog.stdlib.PositionalArgumentsFormatter(),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.stdlib.ProcessorFormatter.wrap_for_formatter,
        ],
        logger_factory=structlog.stdlib.LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
        cache_logger_on_first_use=True,
    )

    # shared processors to be applied to both vanilla and structlog messages
    # after each is appropriately pre-processed
    processors = [
        # log level / logger name, effects coloring in ConsoleRenderer(colors=True)
        structlog.stdlib.add_log_level,
        structlog.stdlib.add_logger_name,
        # timestamp format
        structlog.processors.TimeStamper(fmt="iso"),
        # To see all CallsiteParameterAdder options:
        # https://www.structlog.org/en/stable/api.html#structlog.processors.CallsiteParameterAdder
        # more options include module, pathname, process, process_name, thread, thread_name
        structlog.processors.CallsiteParameterAdder(
            {
                structlog.processors.CallsiteParameter.FILENAME,
                structlog.processors.CallsiteParameter.FUNC_NAME,
                structlog.processors.CallsiteParameter.LINENO,
            }
        ),
        # Any structlog.contextvars.bind_contextvars included in middleware/functions
        structlog.contextvars.merge_contextvars,
        # strip _record and _from_structlog keys from event dictionary
        structlog.stdlib.ProcessorFormatter.remove_processors_meta,
        structlog.dev.ConsoleRenderer(colors=True),
        # ^^ In prod with any kind of logging service (datadog, grafana, etc), ConsoleRenderer
        # would probably be replaced with structlog.processors.JSONRenderer() or similar
    ]

    # Configs applied to logs generated by structlog or vanilla logging
    logging.config.dictConfig(
        {
            "version": 1,
            "disable_existing_loggers": False,
            "formatters": {
                "default": {
                    "()": structlog.stdlib.ProcessorFormatter,
                    "processors": processors,
                    "foreign_pre_chain": [structlog.stdlib.ExtraAdder()],
                },
            },
            "handlers": {
                "default": {
                    "class": "logging.StreamHandler",
                    "formatter": "default",
                    "stream": "ext://sys.stdout",
                },
            },
            "loggers": {
                # "" for applying handler to "root" (all libraries)
                # you could set this to "kernel_sidecar" to only see logs from this library
                "": {
                    "handlers": ["default"],
                    "level": 'INFO',
                    "propagate": True,
                },
                "origami": {
                    "handlers": ["default"],
                    "level": 'DEBUG',
                    "propagate": False,
                },
            },
        }
    )


@pytest.fixture
def jwt():
    token = os.environ.get('NOTEABLE_TOKEN')
    if not token:
        raise RuntimeError('NOTEABLE_TOKEN environment variable not set')
    return token


@pytest.fixture
def api_base_url():
    return 'http://localhost:8001/api'


@pytest.fixture
def test_space_id() -> uuid.UUID:
    return uuid.UUID('edc21f3f-fb30-45fb-a30d-668fac0b0e4a')


@pytest.fixture
def test_project_id() -> uuid.UUID:
    return uuid.UUID('c34e6a11-cc60-4ab6-9566-10f81a4a46cd')


@pytest.fixture
def test_user_id() -> uuid.UUID:
    return uuid.UUID('f9dfb1b5-7ae4-477c-818f-08d0732018d3')


class LogWarningTransport(httpx.AsyncHTTPTransport):
    """
    Automatically log information about any non-2xx response.
    """

    async def handle_async_request(self, request: httpx.Request) -> httpx.Response:
        resp = await super().handle_async_request(request)
        if resp.is_error:
            response_content = await resp.aread()
            logger.warning(f'{request.method} {request.url} {resp.status_code} {response_content}')
        return resp


@pytest.fixture
def api_client(api_base_url, jwt) -> APIClient:
    return APIClient(
        authorization_token=jwt, api_base_url=api_base_url, transport=LogWarningTransport()
    )


@pytest.fixture
async def new_project(api_client: APIClient, test_space_id: uuid.UUID) -> Project:
    name = 'test-project-' + str(uuid.uuid4())
    new_project = await api_client.create_project(name=name, space_id=test_space_id)
    yield new_project
    await api_client.delete_project(new_project.id)


@pytest.fixture
async def file_maker(api_client: APIClient, test_project_id: uuid.UUID):
    file_ids = []

    async def make_file(
        project_id: Optional[uuid.UUID] = None, path: Optional[str] = None, content: bytes = b""
    ) -> File:
        if not project_id:
            project_id = test_project_id
        if not path:
            salt = str(uuid.uuid4())
            path = f'test-file-{salt}.txt'
        file = await api_client.create_file(project_id, path, content)
        file_ids.append(file.id)
        return file

    yield make_file
    for file_id in file_ids:
        # await api_client.delete_file(file_id)
        pass


@pytest.fixture
async def notebook_maker(api_client: APIClient, test_project_id: uuid.UUID):
    notebook_ids = []

    async def make_notebook(
        project_id: Optional[uuid.UUID] = None,
        path: Optional[str] = None,
        notebook: Optional[Notebook] = None,
    ) -> File:
        if not project_id:
            project_id = test_project_id
        if not path:
            salt = str(uuid.uuid4())
            path = f'test-notebook-{salt}.ipynb'
        file = await api_client.create_notebook(project_id, path, notebook)
        notebook_ids.append(file.id)
        return file

    yield make_notebook
    for notebook_id in notebook_ids:
        # await api_client.delete_file(notebook_id)
        pass
